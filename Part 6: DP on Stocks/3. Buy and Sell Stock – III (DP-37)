Leetcode HARD : https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/
Leetcode Solution below:

Problem :You are given an array prices where prices[i] is the price of a given stock on the ith day.
Find the maximum profit you can achieve. You may complete at most two transactions.
Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
SURPRISE : I thought and wrote this recursion by myself for this Leetcode hard problem !

#1 Recursion | TC = O(2^N) :two possibilities for every index | SC=O(N) stack space 

class Solution {
    public int maxProfit(int[] prices) {
        return helper(0, 1, 2, prices);
    }    
    private static int helper(int i, int buy, int atmost, int[] a){
        //base
        if(i == a.length) return 0;
        if(atmost == 0) return 0;
        
        int profit=0;
        if(buy == 1){
            int take = -a[i] + helper(i+1, 0, atmost,  a);
            int notTake = 0 + helper(i+1, 1, atmost, a); 
            profit = Math.max(take , notTake);
        }
        else{
            int sell = a[i] + helper(i+1, 1, atmost-1,  a);
            int notsell = 0 + helper(i+1, 0, atmost, a);
            profit = Math.max(sell , notsell);
        }
        return profit;
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////                                                       
#2. Memoization | TC = O(N x 2 x 3) = No. of states | SC = O(N) aux stack space + O(N x 2 x 3) dp[][][] space

class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int dp[][][] = new int[n][2][3]; // States => buy=0/1  , atmost=0/1/2
        for(int[][] x : dp){
            for(int[] y : x){
                Arrays.fill(y, -1);
            }
        }
        return helper(0, 1, 2, prices, dp);
    }
    
    private static int helper(int i, int buy, int atmost, int[] a, int[][][] dp){
        //base
        if(i == a.length) return 0;
        if(atmost == 0) return 0;
        if(dp[i][buy][atmost] != -1) return dp[i][buy][atmost];
        
        
        int profit=0;
        if(buy == 1){
            int take = -a[i] + helper(i+1, 0, atmost,  a, dp);
            int notTake = 0 + helper(i+1, 1, atmost, a, dp); 
            profit = Math.max(take , notTake);
        }
        else{
            int sell = a[i] + helper(i+1, 1, atmost-1,  a, dp);
            int notsell = 0 + helper(i+1, 0, atmost, a, dp);
            profit = Math.max(sell , notsell);
        }
        return dp[i][buy][atmost] = profit;
    }
}
