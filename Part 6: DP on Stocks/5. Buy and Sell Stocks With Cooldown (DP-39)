Leetcode : https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/
Leetcode Solution below:

Problem : You are given an array prices where prices[i] is the price of a given stock on the ith day.
Find the maximum profit you can achieve. You may complete as many transactions as you like 
(i.e., buy one and sell one share of the stock multiple times) with the following restrictions:
After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).
Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#1 Recursion | TC = O(2^N) | SC=O(N) stack space 

Approach:
1. We travel the array from 0 to n-1.
Pattern:
1. Express everything in terms of (index, buy flag). buy=1=>you can buy | buy=0 => cannot buy but sell
2. Explore all possibilites. 
  [if buy == 1 : either we buy, or we do not buy]
  [if buy == 0 : either we sell, or we do not sell]
  NOTE:  initially we have the liberty to buy. so at i==0, buy=1
3. Take max of all profits.

Use the entire same approach of Buy and Sell Stock-II. 
Modification => SInce we have a cooldown period, after sell, we move to i+2 instead of i+1.



------------ Self Logic-Done -------------------
class Solution {
    public int maxProfit(int[] prices) {
        return helper(0, 1, prices);
    }
    
    private static int helper(int i, int buy, int[] a){
        //base
        if(i >= a.length) return 0;
        
        int profit=0;
        if(buy == 1){
            int take = -a[i] + helper(i+1, 0, a);
            int notTake = 0 + helper(i+1, 1, a);
            profit = Math.max(take, notTake);
        }
        else{
            int sell = a[i] + helper(i+2, 1, a); //if sell, cooldown you cannot buy on th enest day, so move to i+2
            int notsell = 0 + helper(i+1, 0, a);
            profit = Math.max(sell , notsell);
        }
        return profit;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////                                                       
#2. Memoization | TC = O(N x 2) = No. of states | SC = O(N) aux stack space + O(N * 2) dp[][] space


