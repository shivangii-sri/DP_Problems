Leetcode Problem : https://leetcode.com/problems/longest-increasing-subsequence/

---------------------------------------------------------------------------------------------------------------------------------------------------------------
Given an integer array nums, return the length of the longest strictly increasing subsequence.
A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. 
For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].

Eg:  Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.

Constraints:
1 <= nums.length <= 2500
-104 <= nums[i] <= 104
---------------------------------------------------------------------------------------------------------------------------------------------------------------
Rules to Write:
1. Express in terms of (index , prev to keep track of prev element).
2. Explore all possibilities to form subsequence - pick and not pick
3. Return max Increasing length subsequence.
---------------------------------------------------------------------------------------------------------------------------------------------------------------


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
#1 Recursion | | TC = O(2^N) -for every index we have two possibilities pick and not pick    |    SC= O(N) -> aux stack space 
=> gives TLE due to exponential TC


// Recursion - > taking prev index !


class Solution {
    public int lengthOfLIS(int[] nums) {
        return helper(0 , -1 , nums);
    }  
    private static int helper(int i , int prev, int[] a){
        //base
        if(i == a.length) {
            return 0;
        }
        
        int pick = Integer.MIN_VALUE;
        if(prev == -1 || a[i] > a[prev]) pick = 1 + helper(i+1 , i, a);      
        int notpick = 0 + helper(i+1 , prev, a);        
        return Math.max(pick , notpick);
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////                                                        
#2. Memo | TC = O(N x N) -no. of states | SC = O(N x N):-dp[][]  +  O(N):-aux stack space 

==> Memo using Cordinate shift, becuase our prev index is -1, so we will always store in the dp at prev+1

class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        int dp[][] = new int[n][n+1];
        for(int[] x : dp){
            Arrays.fill(x, -1);
        }        
        return helper(0 , -1 , nums , dp);
    }  
    private static int helper(int i , int prev, int[] a, int[][] dp){
        //base
        if(i == a.length) {
            return 0;
        }
        if(dp[i][prev+1] != -1) return dp[i][prev+1]; 
        
        int pick = Integer.MIN_VALUE;
        if(prev == -1 || a[i] > a[prev]) pick = 1 + helper(i+1 , i, a, dp);        
        int notpick = 0 + helper(i+1 , prev, a, dp);
        
        return dp[i][prev+1] = Math.max(pick , notpick);
    }
}
